## 基本类型

- 字符串String
  - 缓存
  - 计数器
  - 共享session
- 字典Hash
- 列表List
  - 消息队列   阻塞队列
  - 文章列表或者数据分页展示     
- 集合Set
  - 比如俩人的好友列表交集
- 有序集合SortedSet
  - 排行榜
  - 做带权重的队列
- 位图 bitmap

## 布隆过滤器

布隆过滤器的原理是，当一个元素被加入集合时，通过**K个散列**函数将这个元素映射成一个位数组中的**K个点**，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。

缺点：

- 存在误判，可能要查询的元素没在容器中
- 删除困难 删除一个之后 可能影响其他元素

hash函数 bit数组

## redis过期

可以在一个固定的时间加上随机值

## redis分布式锁

 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 

## 定时

```shell
EXPIRE runooobkey 60(秒)
```

## 查找对应key

 keys key1111* 

 scan 0 match key1111* count 20 

 SCAN cursor MATCH pattern COUNT count 

## redis异步队列

list作为队列

rpush生产消息

lpop消费消息没有的话 sleep一会试试

blpop 阻塞着直到消息到来

## 订阅模式

pub/sub 实现1：n的消息队列

 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如`RocketMQ`等。 

## 持久化

### rdb

镜像持久化 rdb会比较浪费时间 停机的时候会丢失大量数据

原理：

- fork  redis通过创建子进程来进行RDB操作 
-  cow   子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来 

### aof

增量持久化  也就是日志

为了防止机器突然掉电  所以一秒同步一次

### pipline

 可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性 

## 事务

Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

　　总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

watch key1 key2 ... : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）

　　multi : 标记一个事务块的开始（ queued ）

　　exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　

　　discard : 取消事务，放弃事务块中的所有命令

　　unwatch : 取消watch对所有key的监控

## 缓存雪崩

redis突然失效，导致很多请求突然砸向数据库

过期时间的设置加上随机值 保证不同时过期

## 缓存穿透

缓存和数据库都没有的数据，而用户不断地发出请求

在接口层要增加参数校验，或者使用**布隆过滤器**

## 缓存击穿

 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力 

- 设置热点数据永不过期
- 加互斥锁(分布式锁)