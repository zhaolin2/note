

## 注意点

- 一个表最多16个索引
- count(1)和count(*)
  - count(1)会全表扫描   比count(id)快
  -  count(1)跟count(主键)一样，只扫描主键。
  -  count(*)跟count(非主键)一样，扫描整个表。明显前者更快一些。 
- hash索引一般用来精确索引和等值查询

## 连接器

 客户端建立链接、获取权限、维持和管理连接 

show processlist;

查看空闲连接表

+----+------+----------------+------+---------+------+----------+------------------+
| Id | User | Host           | db   | Command | Time | State    | Info             |
+----+------+----------------+------+---------+------+----------+------------------+
|  2 | root | localhost:5068 | NULL | Sleep   |   21 |          | NULL             |
|  3 | root | localhost:5072 | NULL | Query   |    0 | starting | show processlist |
+----+------+----------------+------+---------+------+----------+------------------+

 **wait_timeout**  客户段默认8个小时没操作 就会断开

长连接：使用长连接之后 内存飙升很快 因为执行过程的临时使用的内存是在连接对象里边的

定期断开  或者执行一个大的查询之后  在断开  

 **mysql_reset_connection**    重新初始化连接资源 

## 缓存 

mysql query cache 的内容为 select 的结果集，在内存中是以 HASH 结构来进行映射。

cache 会使用完整的 sql 字符串做 key，并**区分大小写**，空格等。即两个 sql 必须完全一致才会导致 cache 命中。

在表的结构或数据发生改变时，查询缓存中的数据不再有效。

所以查询缓存适合有大量相同查询的应用，不适合有大量数据更新的应用。

a) 一旦表数据进行任何一行的修改，基于该表相关 cache 立即全部失效，并且从缓冲区中移出；
b) 为什么不做聪明一点判断修改的是否 cache 的内容？因为分析 cache 内容太复杂，服务器需要追求最大的性能。
 在 8.0 版本开始，缓存功能被直接删除。 



 **query_cache_type**设置成为DEMAND，这样SQL默认不适用缓存，想用缓存就用SQL_CACHE。

 select sql_cache count(*) from table_name; 

### 查看真正的执行时间

```sql
select SQL_NO_CACHE * from B
```

## 分析器

你的语句有这么多单词、空格，MySQL就需要识别每个字符串所代表的是什么，是关键字，还是表名，还是列名等等。

然后就开始**语法分析**，根据词法分析的结果，语法分析会判断你sql的对错，错了会提醒你的，并且会提示你哪里错了。

## 优化器

**查询优化器** 一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个 MySQL一条查询语句是如何执行的

### mysql 5.6优化

索引下推  **Index Condition Pushdown（索引下推** ）

 **可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数**。 

 在有like条件查询的情况下，减少回表次数 

## 执行器

 数据库的慢日志有个**rows_examined**字段，扫描多少行可以看到，还有**explain**也可以看到执行计划，我们扫描了多少行。 

### explain

信息一共十列:

| explain的列名 | 候选值                                                       |
| ------------- | ------------------------------------------------------------ |
| id            | id相同时，执行顺序由上至下，内存会认为三个表，乘积小的先执行 |
| select_type   | 表示当前阶段的查询类型，是简单还是子查询                     |
| table         | 表名，<derived**X**>  表示第几步的执行结果                   |
| type          | 表示使用哪种类别，是否使用索引                               |
| possible_keys | 可能使用到的索引                                             |
| key           | 使用到的键                                                   |
| key_len       | 表示使用到的键长度，null表示没使用                           |
| ref           | 连接匹配条件，哪些列或者变量被用于查找索引列上的值           |
| rows          | 执行查询时 所要查询的行数                                    |
| Extra         | 查询的详细信息                                               |

注：各列的候选值

select_type:

- simple 简单的select查询，不包括union以及子查询
- primary 最外层的select查询
- union   表示该查询是union的第二或者随后的查询
- dependent    union   union中的第二或后端的查询语句，取决于外边的查询
- union result  union的结果
- subquery   子查询中的第一个select
- dependent  subquery  子查询中的第一个select  取决于外边的查询  即子查询依赖于外部查询结果

type:

- **ystem**：表中只有一条数据，这是一个特殊的const 类型；
- **const**：针对主键或唯一索引的等值查询扫描，最多只返回一行数据，const 查询速度非常快，因为它仅仅读取一次即可；
- **eq_ref**：此类型通常出现在多表的 join 查询，表示对于前表的每一个结果,都只能匹配到后表的一行结果，并且查询的比较操作通常是＝, 查询效率较高；
- **ref**：此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询；
- **fulltext**：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引；
- **ref_or_null**：与ref方法类似，只是增加了null值的比较。实际用的不多；
- **unique_subquery**：用于where中的in形式子查询，子查询返回不重复值唯一值；
- **index_subquery**：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重；
- **index_merge**：表示查询使用了两个以上的索引，最后取交集或者并集，常见and,or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range；
- **range**：表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN操作中，此时输出的 ref 字段为 NULL并且key_len字段是此次查询中使用到的索引的最长的那个；
- **index**：全表扫描，只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序，但是开销仍然非常大，这种情况时, Extra 字段会显示 Using index；
- **all**：性能最差的情况，使用了全表扫描，系统必须避免出现这种情况。

extra:

- **Distinct**：一旦找到了与行相联合匹配的行就不再搜索了；
- **Using filesort**：使用了文件排序，性能非常慢，需要优化。
- **Using index**：查询使用到了索引，列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。
- **Using temporary**：使用了临时表排序，性能非常慢，需要优化。
- **Using where**：表示使用了where进行查询，不是很重要。
- **ALL**：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，需要优化。

## 引擎

### 索引

#### 分类

**从物理存储角度**

- 聚集索引（clustered index）

- 非聚集索引（non-clustered index）

**从逻辑角度**

-  普通索引   仅加速查询
-  唯一索引  索引的列值必须唯一  但是允许有空值  如果是组合索引  那么列值的组合必须唯一
-  主键索引   特殊的唯一索引
- 组合索引  在多个字段上建立索引  使用时满足最左前缀集合
- 全文索引  主要用来查找文本中的关键字，而不是直接与索引中的值相比较。 

#### 索引存储

 InnoDB 里，聚簇索引B+ Tree的叶子节点存储了整行数据。

而非聚簇索引索引B+ Tree的叶子节点存储了主键的值。 

联合索引的叶子节点和中间节点存储是以第一个为key值进行存储的   所以会有最左前缀匹配

最左匹配原则中，有如下说明：

1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

##### 带来的问题

**回表**  使用其他索引查出来主键之后  再去主键的B+树中查找

**索引覆盖**   将被查询的字段，建立到联合索引里去。 

```sql
select id,name,sex from user where name='shenjian';
#  需要回表查询
index(name, sex)   升级到name,sex 就可以不用回表了
```

### 为什么使用B+树

1 b+树的数据都集中在叶子节点。分支节点 只负责索引。 b树的分支节点也有数据 。 b+树的层高 会小于 B树   所以平均IO次数也会比较小

2 b+树更擅长范围查询。叶子节点 数据是按顺序放置的双向链表。 b树范围查询只能中序遍历。

3  索引节点没有数据。比较小。b树可以吧索引完全加载至内存中。

### 并发访问下对更新的覆盖

添加version

select for update //表记锁

## mysql事务

ACID：原子性，一致性，隔离性，持久性。

​		原子性（Atomicity）：**事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行**。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

​		一致性（Consistent）：**在事务开始和完成时，数据都必须保持一致状态**。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。

​		隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。 **隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离**。即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

​		持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。 　可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。



四个特性，最重要的就是一致性。而**一致性**由原子性，隔离性，持久性来保证。

- 原子性由 Undo log 保证。Undo Log 会保存每次变更之前的记录，从而在发生错误时进行回滚。
- 隔离性由 MVCC 和 Lock 保证。这个后面说。
- 持久性由 Redo Log 保证。每次真正修改数据之前，都会将记录写到 Redo Log 中，只有 Redo Log 写入成功，才会真正的写入到 B+ 树中，如果提交之前断电，就可以通过 Redo Log 恢复记录。

### 并发一致性问题

1.更新丢失

 **T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改**。 

2.脏读

 **T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据**。 

3.不可重复读

 **一个事务范围内两个相同的查询却返回了不同数据**。 

4.幻读

 事务A 读取到了事务B提交的新增数据，不符合隔离性。 

### 数据库隔离级别

RU,RC,RR,Ser

 未提交读(read uncommitted)、已提交读(read committed)、可重复读(repeatable read)、串行化(serializable)。              |

- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
  - 所有事务是都可以看到其他事务没提交的结果
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
  - 一个事务只能看到已经提交的事务的结果
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读
  - 确保 同一事务的多个实例在并发读取数据时，会看到同样的数据行  mvcc
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

## mvcc

 Multi-Version Concurrency Control,翻译为中文即 多版本并发控制 

### 隐藏字段

- DB_TRX_ID(6字节)：表示最近一次对本记录行作修改（insert | update）的事务ID。至于delete操作，InnoDB认为是一个update操作，不过会更新一个另外的删除位，将行表示为deleted。并非真正删除。

- DB_ROLL_PTR(7字节)：回滚指针，指向当前记录行的undo log信息
- DB_ROW_ID(6字节)：随着新行插入而单调递增的行ID。理解：当表没有主键或唯一非空索引时，innodb就会使用这个行ID自动产生聚簇索引。如果表有主键或唯一非空索引，聚簇索引就不会包含这个行ID了。这个DB_ROW_ID跟MVCC关系不大。

### Readview

表示能看到的视图

-   **low_limit_id**：目前出现过的最大的事务ID+1，即下一个将被分配的事务ID 
-  **up_limit_id**：活跃事务列表trx_ids中最小的事务ID，如果trx_ids为空，则up_limit_id 为 low_limit_id 
-  **trx_ids：**Read View创建时其他未提交的活跃事务ID列表 
-  creator_trx_id：**当前创建事务的ID 

每次查看的时候，首先跟最大的事务id和最小的事务id进行比较

<最小的 说明已经提交了 所以显示

大于最大的  说明是在创建之后才产生的，所以不显示

在这俩之间 二分查找 不存在可以显示

存在不显示

不满足Read Review的时候，从undo log里边获取数据

### 事务具体实现

每次去Read Review里边查找，不对的话，undo log查找上一条，然后再显示

参考： https://zhuanlan.zhihu.com/p/52977862 

 [https://blog.csdn.net/Waves___/article/details/105295060#1.2%E3%80%81Read%20View%20%E7%BB%93%E6%9E%84](https://blog.csdn.net/Waves___/article/details/105295060#1.2、Read View 结构) 


## mysql和Oracle的区别

limit 1

where column=1

## 数据库join

inner join

left join

right join 

full join

nature join

## sql优化

 1、避免在where子句中使用 is null 或 is not null 对字段进行判断。 

 2、避免在 where 子句中使用 != 或 <> 操作符。 

 避免在 where 子句中使用 or来链接条件。

 4、少用 in 或 not in。 

 5、注意 like 中通配符的使用。  

 6、避免在 where 子句中对字段进行表达式操作。 

 7、避免在 where 子句中对字段进行函数操作。 

 8、在子查询中，用 exists 代替 in 是一个好的选择。 

## 日志

undo log除了实现MVCC外，还用于事务的回滚。MySQL Innodb中存在多种日志，除了错误日志、查询日志外，还有很多和数据持久性、一致性有关的日志。

binlog，是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的, 另外通过解析binlog能够实现mysql到其他数据源（如ElasticSearch)的数据复制。

redo log记录了数据操作在物理层面的修改，mysql中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)。为了保证数据的安全性，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中, redo log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据redo log进行**数据的恢复**，如果redo log中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性。

undo log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现**事务回滚**，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。

## 数据库锁

### 类型维度

- 共享锁（读锁 / S 锁）

- 排它锁（写锁 / X 锁）
  类型细分：

- - 意向共享锁
  - 意向排他（互斥）锁

- 悲观锁（使用锁，即 for update）

- 乐观锁（使用版本号字段，类似 CAS 机制，即用户自己控制。缺点：并发很高的时候，多了很多无用的重试）

### 锁的粒度（粒度维度）

- 表锁
- 页锁（Mysql BerkeleyDB 引擎）
- 行锁（InnoDB）

### 锁的算法（算法维度）

- Record Lock（单行记录）
- Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）
- Next-Key Lock（Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现）

### 默认的读操作，上锁吗？

- 默认是 MVCC 机制（“一致性非锁定读”）保证 RR 级别的隔离正确性，是不上锁的。