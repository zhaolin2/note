## 字符

**字符：**在计算机和电信技术中，一个字符是一个单位的字形、类字形单位或符号的基本信息。即一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号等。

**字符集：**多个字符的集合。例如GB2312是中国国家标准的简体中文字符集，GB2312收录简化汉字（6763个）及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。

**字符编码：**把字符集中的字符编码为（映射）指定集合中的某一对象（例如：比特模式、自然数序列、电脉冲），以便文本在计算机中存储和通过通信网络的传递。

字符集和字符编码的关系 ：
字符集是书写系统字母与符号的集合，而字符编码则是将字符映射为一特定的字节或字节序列，是一种规则。通常特定的字符集采用特定的编码方式（即一种字符集对应一种字符编码（例如：ASCII、IOS-8859-1、GB2312、GBK，都是即表示了字符集又表示了对应的字符编码，但Unicode不是，它采用现代的模型）），因此基本上可以将两者视为同义词。



由于计算机底层使用二进制数来存储和传输数据，而我们人类使用文字、数字和图形符号来表达信息，因此两者之间需要通过某种**映射关系**来实现。根据映射方向的不同，又可以分为编码和解码。

文字、数字等转换成二进制数被称为**编码**，

二进制数转化为文字、数字和图形符号等称为**解码**。

其中，文字与符号总称为字符（Character），而字符的集合就是**字符集**（Charset）。常见的字符集包括ASCII字符集、GB2312字符集（简体字符集）、GBK字符集（简繁字符集）和通用字符集（UCS）和Unicode字符集。

字 符编码必须完成如下两件事：

（1）规定一个字符集中的字符由多少个字节表示
（2）制定该字符集的字符编码表，即该字符集中每个字符对应的（二进制）值。
 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。  高位在前 低位在后

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。 低节在前 高节在后

## 数据结构


### 线性表

 线性表*（linear list）*是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。 

#### 数组 

 数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。 

1. ​     按照索引查询元素速度快
2、按照索引遍历数组方便 

#### 链表

 链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。 

链表的优点：
链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；
添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；

缺点：
因为含有大量的指针域，占用空间较大；
查找元素需要遍历链表来查找，非常耗时。

适用场景：
数据量较小，需要频繁增加，删除操作的场景



##### 数组和链表

​		增加的时间=查找的时间+操作的时间

增加和删除：

​	知道**下标**的时候   差不多都是O(n)

​	知道**引用**   链表快点

查找

​	知道**下标** 数组快

​	查找**对应数值**  数组快点

#### 队列

 队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。 

#### 栈

 栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出。

### 树

 **树**是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 

- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；

遍历

​	先序  中左右

​	后序   左右中

​	中序	左中右

### 散列表

 散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。 

 **地址index=H（key）** 

hash函数

 H（key）=a*key+b 

 H（key）=key MOD p （p<=m m为表长） 

 1.计算散列地址所需要的时间（即hash函数本身不要太复杂）
2.关键字的长度
3.表长
4.关键字分布是否均匀，是否有规律可循
5.设计的hash函数在满足以上条件的情况下尽量减少冲突 

hash冲突

 **1.开放定制法**
**2.链地址法**    加上指针 多的就放在后边
**3.公共溢出区法**
建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。
**4.再散列法**       若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个 

 **装载因子** α=n/m(n表示实际装载数据长度 m为表长) 

### 堆

堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：

- 堆中某个节点的值总是不大于或不小于其父节点的值；
- 堆总是一棵完全二叉树。

 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 

 ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4…n/2) 

父节点 2i+1   子节点i/2  -1

#### 堆排序

升序使用大根堆  降序采用小根堆

构建过程：

从最后一个非叶子节点开始 

​			从左到右   从下至上来进行构建  得到大根堆

把堆顶元素跟最后一个元素互换  则最后一个元素最大

然后排除最后一个元素 继续调整堆 得到第二大元素

最后得到一个有序序列

 堆排序是一种**选择排序**，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。

其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。 

### 图

 图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。 

 在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。 

存储方式

​	邻接表   每个顶点会存储 从他这里开始的列表

​	邻接矩阵  行和列来表示顶点  两个顶点对应的元素来代表

广度优先	BFS  每次便利的时候 把邻接表的元素加入要便利的集合  queue

深度优先  DFS    每次选择一个元素进行遍历，然后遍历到最深处，回退一步 继续遍历   stack

 ## 排序

希尔排序最好的情况下时间复杂度为：O(nlog(n))，最坏的情况下是 O(nlog(n)^2)，插入排序最好的情况下时间复杂度为：O(n)，最坏的情况下是：O(n^2)，所以希尔排序最好的情况下还是要比插入排序最坏的情况下要快。 



 RIP是路由信息协议，SMTP与邮件有关的协议，ARP是地址解析协议 



## 树

### 二叉树

​	 二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有**2的i-1次方**个结点；深度为k的二叉树至多有**2的k-1次方**个结点；

​	对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。 

#### 满二叉树

 	满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。

​	满二叉树的性质：

　　1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;

　　2) 叶子数为2的h次方;

　　3) 第k层的结点数是：2的k-1次方;

　　4) 总结点数是：2的k-1次方，且总节点数一定是奇数。 

#### 完全二叉树

 	完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。 

### 二叉查找树

又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

　　1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；

　　2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；

　　3) 左、右子树也分别为二叉排序树；

　　4) 没有键值相等的节点。

 ***二叉查找树的高度决定了二叉查找树的查找效率。***

### 平衡二叉树

 	平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。 

#### AVL树

​	 在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。 

#### 红黑树

 	**它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。** 

**红黑树的性质：**

　　红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

　　性质1. 节点是红色或黑色。

　　性质2. 根是黑色。

　　性质3. 所有叶子都是黑色（叶子是NIL节点）。

　　性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)

　　性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

### B树

 	**B树的定义：**B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。

 B+树是B树的变体，也是一种多路搜索树： 

1) 其定义基本与B-树相同，除了：

　　2) 非叶子结点的子树指针与关键字个数相同；

　　3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；

　　4) 为所有叶子结点增加一个链指针；

　　5) 所有关键字都在叶子结点出现； 

堆

堆左边节点 k2i  右边k2i+1



根据堆的定义堆实际上是一棵完全二叉树，其任何一非叶节点满足性质：即分为**最大堆**：根节点大于或等于左右子结点；**最小堆**：节点小于或等于左右子结点。

 **Key[i]<=key[2i+1]&&Key[i]<=key[2i+2]或者Key[i]>=Key[2i+1]&&key>=key[2i+2]**



**ARP欺骗攻击：** 分为对路由器ARP表的欺骗和对内网PC的网关欺骗。 第一种ARP欺骗的原理是——截获网关数据。 第二种ARP欺骗的原理是—  —伪造网关。

**重放攻击：**重放攻击（Replay Attacks）又称重播攻击、回放攻击或新鲜性攻击（FreshnessAttacks）是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。

**暴力攻击：**暴力破解攻击是指攻击者通过系统地组合所有可能性（例如登录时用到的账户名、密码），尝试所有的可能性破解用户的账户名、密码等敏感信息。攻击者会经常使用自动化脚本组合出正确的用户名和密码。

**DNS欺骗攻击：**DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址。



 在 MySql 中，以下哪种备份方式是在某一次完全备份的基础，只备份其后数据的变化？   增量备份



 降低进程优先级的最合理的时机是（） 。 进程的时间片用完



数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号的集合。

数据元素：是组成数据的、有一定意义的基本单位。

数据对象：是性质相同的数据元素的集合，是数据的子集。

抽象数据类型：一个数学模型以及定义在此模型上的一组操作。其三个组成部分为：数据对象、数据关系和基本操作。

而 **数据结构简单地理解就是关系**。

定义：**数据结构是相互之间存在一种或多种特定关系的数据元素的集合**。



 无向图特有:连接多重表。有向图特有:十字链表，边集数组。二者共有:邻接表，邻接矩阵。 



 不含任何结点的空树是什么 



页表表项中的**访问位**是由CPU置位的

页表表项中的**存在位**是由操作系统代码置位的



 计算机网络拓扑结构是指网络中各个站点相互连接的形式，各个站点抽象来说都是网络资源。
计算机网络的最主要的拓扑结构有总线型拓扑、环型拓扑、树型拓扑、星型拓扑、混合型拓扑以及网状拓扑。其中环形拓扑、星形拓扑、总线拓扑是三个最基本的拓扑结构。在局域网中，使用最多的是星型结构。 



 耗时的操作在线程中进行，因为这样并行计算可以**防止主界面卡顿**。

C 如果是在多处理器计算机中多个程序可以真正的并行执行，可以提高使用cpu的效率。

D 线程不能独立执行程序。



(1)冒泡排序

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。

(2)选择排序

选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

(3)插入排序

插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。

(4)快速排序

快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j, 交换a[i]和a[j],重复上面的过程，直到i>j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。

(5)归并排序

归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。

(6)基数排序

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

(7)希尔排序(shell)

希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

(8)堆排序

我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, ...1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。

综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。



 系统中的资源可以分为两类，**一类是可剥夺资源**，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。例如，优先权高的进程可以剥夺优先权低的进程的 [处理机](http://baike.baidu.com/view/2107226.htm) 。又如，内存区可由 [存储器管理](http://baike.baidu.com/view/364948.htm) 程序，把一个进程从一个存储区移到另一个存储区，此即剥夺了该进程原来占有的存储区，甚至可将一进程从内存调到外存上，可见， [CPU](http://baike.baidu.com/view/2089.htm) 和 [主存](http://baike.baidu.com/view/313837.htm) 均属于可剥夺性资源。**另一类资源是不可剥夺资源**，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如 [磁带机](http://baike.baidu.com/view/220750.htm) 、打印机等。 



**1.网络模型**

![img](https://segmentfault.com/img/bVwBSX)

**OSI七层模型**

7 应用层：允许访问网络资源。 通信单位：报文（指的是TCP/IP协议里广义的应用层 ） 
6 表示层：数据的转换，加密，压缩 
5 会话层：建立，管理，终止会话 
4 运输层：提供可靠的进程到进程的交付和差错恢复。 
3 网络层：从源到终点传送分组，提供网络互联。通信单位 数据报 
2 数据链路层：将比特组织成帧结构，提供逐跳交付。通信单位 帧 
1 物理层：经过媒体传送比特

**2.TCP与UDP**

**UDP（** **User Datagram Protocal，** **用户数据报协议** **）**

（1）简介

面向数据报的不可靠的 传输层通信协议

（2）特点

UDP不能保证可靠传输，也就更不能保证所发送的数据的到达顺序，它所实现的是尽最大的努力交付。

UDP是面向数据报文的、无连接的协议，因此它的开销低并且发送器前的时延小（因为不用建立连接啊），面向报文也使得IP层在传输UDP协议的报文时既不会拆分也不会合并。

UDP可以支持一对一、一对多、多对一、多对多的通信。

UDP没有拥塞控制功能，它的发送速率不会随着网络出现的拥塞而降低，所以它的实时性较好。这也是许多视频聊天应用采用它的原因。

（3）报文格式



**TCP（** **Transmission Control Protocol，** **传输控制协议** **）**

（1）简介

面向连接的、可靠的、基于字节流的传输层通信协议

（2）特点

TCP协议保证可靠传输，也就是说发送的数据是什么样，接收的数据也是什么样。

TCP协议是有连接的、面向数据流的协议。有连接是说数据传送前通信双方需要建立连接、通信完毕后需要断开连接，不过这里所提到的连接都是逻辑上的连接。面向数据流的意思是说发送方应用程序发送的数据是什么顺序，接收方应用读取的接收到的数据也是什么顺序。

TCP协议提供的是端到端的通信，也就是说一条TCP连接只能提供一对一的通信。不过，一个应用可以同时建立多条TCP连接来实现与多个目标的通信。

TCP协议提供拥塞控制功能，会在网络状况良好的情况下适当提高发送/接收速率，反之则适当降低发送/接收速率。这样，将会提高对网络的利用率。

（3） 数据封包结构



**3.参考网址**

https://segmentfault.com/a/1190000004598598



 HTTP的端口号是80，https的端口号是443，两者不能混淆了 



 **dhclient命令**使用动态主机配置协议动态的配置网络接口的网络参数。 



 栈和队列都是特殊的线性表，对插入删除有限制。 栈 先进后出 在表尾进行插入和删除 队列 先进先出 在表尾进行插入，表头进行删除 

线性表

init进程是所有linux进程的父进程，进程号为1，也是内核态转用户态的入口，通过调用init函数，由1号内核态进程转成init进程。

但是0号内核态进程是所有进程的祖先这句话怎么说？



 【解析】在栈中，栈底保持不变，有元素入栈，栈顶指针增加；有元素出栈，栈顶指针减小。在循环队列中，队头指针和队尾指针的动态变化决定队列的长度。在循环链表中，前一个结点指向后一个结点，而最后一个结点指向头结点，只有头结点是固定的。线性链表中，由于前一个结点包含下一个结点的指针，尾结点指针为空，要插入删除元素，只需要改变相应位置的结点指针即可，头指针和尾指针无法决定链表长度。故本题答案为 A 选项。 



```
数据库设计通常分为6个阶段1（需求分析：分析用户的需求，包括数据、功能和性能需求；2概念结构设计：主要采用E-R模型进行设计，包括画E-R图；3逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；4数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；5数据库的实施：包括编程、测试和试运行；6数据库运行与维护：系统的运行与数据库的日常维护。）,主要讨论其中的第3个阶段,即逻辑设计。通过一个实际的案例说明在逻辑设计中E-R图向关系模式的转换
```

 CPU一般都会标有多少GHz，表示处理器的处理频率。 

 深度用栈，广度遍历用队列 



 在TCP/IP互联网中，服务器程序通常使用TCP协议或UDP协议的端口号作为自己的特定标识。在服务器程序启动时，它首先在本地主机注册自己使用的TCP或UDP端口号。故本题答案为A。 

第七层是应用层，为特定类型的网络应用提供了访问OSI环境的手段。应用层确定进程之间通信的性质，以满足用户的需要。常见的协议包括HTTP,HTTPS,FTP,TELNET,SSH,SMTP,POP3等。

第六层是表示层，主要处理两个通信系统中交换信息的表示方式。为上层用户解决用户信息的语法问题。包括数据格式交换、数据加密与解密、数据压缩与终端类型的交换。

第五层是会话层，在两个结点之间建立端连接。为端系统的应用程序之间提供对话控制机制。此服务包括建立连接是以全双工还是半双工的方式进行设置，尽管可以在第四层中处理双工方式；会话层管理登入和注销过程。

第四层是传输层，常规数据传递，为会话层用户提供端到端的可靠、透明和优化的数据传输服务机制。包括全双工或半双工、流量和错误恢复服务；传输层把消息分成若干分组，并在接收端对它们进行充足。

一般情况下虚拟内存的大小大于物理内存与外部存储的大小总和。

比如对于一台80x86上运行的32位Linux，其可寻址的物理地址空间为4GB，虚存大小上限为 4GB ＊ 进程数上限。



 SMTP采用“推”的通信方式，在用户***向邮件服务器及邮件服务器之间发送邮件时，SMTP客户主动将邮件“推”送到SMTP服务器。而POP3采用“拉”的通信方式，当用户读取邮件时，用户***向邮件服务器发出请求，“拉”取用户邮箱中的邮件。 



 说明：在C++中友元函数是独立于当前类的外部函数，一个友元函数可以同时定义为两个类的友元函数，友元函数既可以在类的内部，也可以在类的外部定义；在外部定义友元函数时，不必加关键字friend 



 软件工程是一种( )分阶段实现的软件程序开发方法。  自顶向下



union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

union All：对两个结果集进行并集操作，包括重复行，不进行排序；

 

 虚拟存储管理中的抖动(thrashing)现象是指页面调度的时间用于换页的时间远多于执行程序的时间 

 是可以被打断的 只是不能进入临界区 

 若进程A和进程B在临界段上互斥，那么当进程A处于该临界段时，它不能被进程B中断 

链接：https://www.nowcoder.com/questionTerminal/16cefe6a65b9490fb5d317f9a0b71002?orderByHotValue=0&mutiTagIds=2656&page=2&onlyReference=false来源：牛客网

```
在Select子句的后面，只能有两种类型的表达式，一种是合计函数，一种是出现在Group By子句后面的列名
不能在子查询中包含Order By 子句
如果子查询的结果为空，那么外查询条件始终不会成立
```



进程通信

## 管道

## FIFO

 FIFO，也称为命名管道，它是一种文件类型。 

## 消息队列

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

## 信号量

信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

## 共享内存

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。



BigEndian原则是高低高低 字节序高内存地址低

LittleEndian原则是高高低低  字节序高内存地址高



链接：https://www.nowcoder.com/questionTerminal/5f336ab003ae4cf08707eb56faf279b8来源：牛客网

 [查看正确选项](javascript:void(0)) 

正确答案：A C



 **方法中的局部变量在****方法被调用加载时开始入栈时创建，****方法入栈创建栈帧包括局部变量表操作数栈，局部变量表存放局部变量****，并非在执行该方法时被创建，C错误** 





# 在局域网模型中，数据链路层分为（）。

## 

A . 逻辑链路控制子层和网络子层



交 并 连接 笛卡尔积



1) 列出‘20140810’日所有本行为‘工行’的交易流水(要求：仅输出交易流水号、交易币种、交易金额)；



2) 通过一个SQL完成数据汇总功能并将结果插入到交易汇总表；



3) 给交易汇总表增加一个合理的唯一索引。



每一个线程都会有一个消息队列，

```
SendMessage等待消息处理完成后返回
PostMessage将一个消息送到另一个线程就返回
```

 DLL，是一种不可执行的二进制程序文件，它允许程序共享执行特殊任务所必需的代码和其他资源。 

串 线性表



**封闭性：**指的是程序一但开始执行，其计算结果就取决于程序本身，不受外界因素影响。

**可再现性：**是指当程序重复执行多次时，必将得到相同结果。

**事实：**程序并发执行的时候可能失去封闭性和可再现性（即 一个多道程序可能具有封闭性和可再现性）



 进程控制块(PCB)是用来记录进程状态及其他相关信息的数据结构,PCB是进程存在的唯一标志，PCB存在则进程存在。系统创建进程时会产生一个PCB，撤销进程时，PCB也自动消失。 



 进程的三种基本状态： 就绪(Ready)状态 当进程已分配到除CPU 以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。 执行（Running）状态 当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。 阻塞(Blocked)状态 正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态搜索。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。 



**长程调度**，又称为作业调度或高级调度，这种调度将已进入系统并处于后备状态的作业按某种算法选择一个或一批，为其建立进程，并进入主机，当该作业执行完毕时，还负责回收系统资源，在批处理系统中，需要有作业调度的过程，以便将它们分批地装入内存，在分时系统和实时系统中，通常不需要长期调度。它的频率比较低，主要用来控制内存中进程的数量。 

**中程调度**，又称为交换调度。它的核心思想是能将进程从内存或从CPU竞争中移出，从而降低多道程序设计的程度，之后进程能被重新调入内存，并从中断处继续执行，这种交换的***作可以调整进程在内存中的存在数量和时机。其主要任务是按照给定的原则和策略，将处于外存交换区中的就绪状态或等待状态的进程调入内存，或把处于内存就绪状态或内存等待状态的进程交换到外存交换区。 

**短程调度**，又称为进程调度、低级调度或微观调度。这也是通常所说的调度，一般情况下使用最多的就是短期调度。它的主要任务是按照某种策略和算法将处理机分配给一个处于就绪状态的进程，分为抢占式和非抢占式。 可以从下图中清晰的看到这些调度之间的区别。

**1、fork**

一个程序一调用fork函数，系统就为一个新的进程准备了前述三个段，首先，系统让新的进程与旧的进程使用同一个代码段，因为它们的程序还是相同的，对于数据段和堆栈段，系统则复制一份给新的进程，这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。而如果两个进程要共享什么数据的话，就要使用另一套函数（shmget，shmat，shmdt等）来操作。现在，已经是两个进程了，对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零，这样，对于程序，只要判断fork函数的返回值，就知道自己是处于父进程还是子进程中。事实上，目前大多数的unix系统在实现上并没有作真正的copy。一般的，CPU都是以“页”为单位分配空间的，象INTEL的CPU，其一页在通常情况下是4K字节大小，而无论是数据段还是堆栈段都是由许多“页”构成的，fork函数复制这两个段，只是“逻辑”上的，并非“物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的“页”从物理上也分开。系统在空间上的开销就可以达到最小。

 **2、exec**

一个进程一旦调用exec类函数，它本身就“死亡”了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。不过exec类函数中有的还允许继承环境变量之类的信息，这个通过exec系列函数中的一部分函数的参数可以得到。