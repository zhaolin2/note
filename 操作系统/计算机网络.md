

## 应用层

### http

超文本传输协议

**Request**结构

- 请求行	 GET /562f25980001b1b106000338.jpg HTTP/1.1   方法名称 资源名 协议名称
- 请求头  需要的附加信息
- 空行   \r\n
- 请求数据  可以添加任意的信息

**Response**结构

- 状态行   **HTTP协议版本号， 状态码， 状态消息** 
- 消息报头
- 空行
- 响应正文

### 常用方法

get post  put delete head(用于获取报头)

#### get post区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。

get产生一个数据包 post产生两个数据包

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 

### FTP

 FTP（File Transfer Protocol）文件传输协议，在TCP/IP协议族中属于应用层协议运行于TCP协议之上是一种可靠的传输协议，主要功能用于实现用户间文件分发共享，以及网络管理者在进行设备版本升级、日志下载和配置保存等业务操作时，均会使用到FTP功能。

-  采用c/s架构

### 表示层

#### telnet

 Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器)。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。 

### 会话层

#### SMTP

 **SMTP** 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。 

Imap是本地跟云端保持双向同步的协议，如果要做到只删除云端邮件保留本地邮件，还是要使用单向同步的pop3协议，所以如果需要本地做备份的话，也是推荐电脑端使用pop3，这样当你在手机上或者云端删除邮件的时候，不会影响你已经下载到Mac里的备份。

另外，Foxmail在IOS端叫QQ邮箱。

 ![img](https://pic4.zhimg.com/80/v2-6090a8eaefda0b1fc3b041fe5353d29b_720w.jpg) 



#### DNS

DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。

### dns获取ip

当浏览器拿到输入的 [http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com) 后，首先会去浏览器的 dns 缓存中去查询是否有对应记录，如果查询到记录就可以直接返回 ip 地址，完成解析。

如果浏览器没有缓存，那就再去查询操作系统的缓存，同样的，如果查询到记录就可以直接返回 ip 地址，完成解析。

如果操作系统也没有缓存，那就再去查看本地 host 文件，Windows 下 host 文件一般位于 "C:\Windows\System32\drivers\etc"。

如果本地 host 文件也没有相应记录，那就需要求助于本地 dns 服务器了，所以应该要知道本地 dns 的 ip 地址。

本地 dns 服务器 ip 地址一般是由本地网络服务商如移动、电信提供，一般是通过 DHCP 自动分配，当然你也可以自己手动配置。目前用的比较多的是谷歌提供的公用 dns 8.8.8.8 和国内的公用 dns 114.114.114.114 

找到本地 dns 后，它也会先去查询一遍它自己的缓存，如果有记录就返回，如果没有记录，它将开始要去我们前面提到的根域名服务器查询了。注意由于根域名服务器 ip 地址一般都是固定的，所以本地 dns 服务器一般都内置了根域名服务器 ip 地址。

目前全球一共有 13 组根域名服务器（这里并不是指 13 台服务器，是指 13 个 ip 地址，按字母 a-m 编号），为了能更高效完成全球所有域名的解析请求，根域名服务器本身并不会直接去解析域名，而是会把不同的解析请求分配给下面的其他服务器去完成，下面是 dns 域名系统的树状结构图。

下面用一张图来展示上面迭代查询的过程。





![img](https://pic3.zhimg.com/80/v2-174cda4e0cb52f961ae21d61bb34281e_720w.jpg)




## 传输层

### TCP

 **面向字节流**

面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。

### 三次握手

 ![img](https://pic1.zhimg.com/80/v2-460c0ce6abfd79f18e35266ad5dbb6d4_720w.jpg) 

**第一次握手：** 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入**SYN_SEND**状态，等待服务器的确认；

**第二次握手：** 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入**SYN_RECV**状态；

**第三次握手：** 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入**ESTABLISHED**状态，完成TCP三次握手。

### 四次挥手

 ![img](https://pic4.zhimg.com/80/v2-5c6bacfb3ebc43147f7f9ee4e21b34ff_720w.jpg) 

**第一次分手：** 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入**FIN_WAIT_1**状态；这表示主机1没有数据要发送给主机2了；

**第二次分手：** 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入**FIN_WAIT_2**状态；主机2告诉主机1，我“同意”你的关闭请求；

**第三次分手：** 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入**LAST_ACK**状态；

**第四次分手：** 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入**TIME_WAIT**状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

### 为什么要等待2MSL？

MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。

原因有二：

- 保证TCP协议的全双工连接能够可靠关闭
- 保证这次连接的重复数据段从网络中消失

### 流量控制

 **滑动窗口机制**可以很方便地在TCP连接上实现对发送方的流量控制。 

 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 **rwnd** = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。 

### 拥塞控制

发送方维持一个拥塞窗口 **cwnd** ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。

发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

一般网络拥塞以丢包作为信号

-  超时重传RTO[Retransmission Timeout]超时 
-  收到三个重复确认ACK 

#### 慢开始算法

 1) 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。

 2) 每当收到一个ACK，cwnd大小加一，呈线性上升。 

3) 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。 

4) 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法） 



为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限**ssthresh**状态变量。慢开始门限ssthresh的用法如下：

- 当 cwnd < ssthresh 时，使用上述的慢开始算法。

- 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

- 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

#### 拥塞避免

   1) 收到一个ACK，则cwnd = cwnd + 1 / cwnd 2) 每当过了一个往返延迟时间RTT，cwnd大小加一。 

#### 快重传

快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。

由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。

- cwnd大小缩小为当前的一半
- ssthresh设置为缩小后的cwnd大小
- 然后进入快速恢复算法Fast Recovery。

#### 快恢复

- cwnd = cwnd + 3 * MSS，加3 * MSS的原因是因为收到3个重复的ACK。
- 重传DACKs指定的数据包。
- 如果再收到DACKs，那么cwnd大小增加一。
- 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。

### 什么时候应该使用TCP？

当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。

### UDP

 **面向报文**

面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。

#### 什么时候应该使用UDP？

当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 

比如:dns解析

### tcp和udp比较

 ![img](https://pic3.zhimg.com/80/v2-3cdbcf0100f88b32af1d2e0a52285c3a_720w.jpg) 

## 网络层

### IP

 A类IP地址: 0.0.0.0~127.0.0.0
B类IP地址:128.0.0.1~191.255.0.0
C类IP地址:192.168.0.0~239.255.255.0 



TCP/IP端口占据两个字节，0~65535。端口分为三类：

1.公共端口（0~1023），由IANA机构分配，也叫“well known ports”；

2.注册端口（1024~49151），由公司或者其他机构向互联网名称与数字地址分配机构（ICANN）登记的端口号；

3.动态端口（49152~65535），客户端使用的端口号，使用时动态分配。

### ARP

 ARP 是根据IP地址获取MAC地址的一种协议。

ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的**ARP高速缓存**（就是一个IP-MAC地址对应表缓存）。

如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的**MAC地址的ARP包**传送给发送ARP广播的主机。

而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。

**RARP相反**

### ICMP

 ICMP(网络控制报文) 

 当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。 

**ping**就是使用icmp来进行网络是否联通

### Traceroute

 **Traceroute**是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。 

 Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。 

- 第一个发送一个ttl=1的包 得到第一跳的地址 然后icmp返回请求回显
- 第二个发送ttl=2的包。。。  最后就得到途径的路由地址

## 网络接口层

主要通过mac地址来进行发送 以帧为最小单位

**主要特点**

- 封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。
- 透明传输:零比特填充、转义字符。
- 可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。
- 差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。





IPV4中，数据包传播方式包括以下的(  )

- ```
  广播
  ```

- ```
  单播
  ```

- ```
  任播   ipv6
  ```

- ```java
  组播
  ```



## 加密算法

### 对称加密

对称加密是指加密与解密的使用同一个密钥的加密算法。小编初中的时候传纸条使用了同一套加密密码，所以我用的加密算法就是对称加密算法。

目前常见的加密算法有：DES、AES、IDEA 等

### 非对称加密

非对称加密使用的是两个密钥，公钥与私钥，我们会使用公钥对网站账号密码等数据进行加密，再用私钥对数据进行解密。这个公钥会发给查看网站的所有人，而私钥是只有网站服务器自己拥有的。

目前常见非对称加密算法：RSA，DSA，DH等。

## https

http的内容是没有加密的  

所以https使用对称加密算法，但是如果密钥被中间截获，那么还是可能不安全

那么这个对称密钥，加密传输

- 客户段发起ssl连接
- 服务器返回公钥
- 客户段发送对称密钥(使用公钥加密)
- 使用对称密钥加密

可能不安全  使用CA

身份证书的三个作用

- 身份验证 确保浏览器访问的网站时经过CA认证的可信任的网站
- 分发公钥  每个数字证书都熬喊了注册者生成的公钥
- 验证证书合法性  客户段收到证书之后 会对合法性进行验证

第一

client向server发送请求[https://baidu.com](https://link.zhihu.com/?target=https%3A//baidu.com)，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。

第二

server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。

第三

从随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。

第四

客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。

第五

客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。

第六

传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。

第七

服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。

第八

客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。

第九

同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。




