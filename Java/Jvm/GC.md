## 年龄和晋升

新对象一般在Eden分配，经过一次gc，对象年龄+1(Eden-> Survivor)，增加到一定程度(默认15)之后晋升到老年代。

实际上15其实区分垃圾回收器的，cms的默认年龄就是6

### 动态年龄判定

在遍历对象的时候，按照年龄从小到大进行累积，当某个年龄**超过survivor的一半**，取年龄和参数 MaxTenuringThreshold 中更小的值作为阈值。

## 对象死亡分析

### 引用计数法

给对象添加引用计数器，每当有一个地方引用，就+1，引用失效就-1，无法解决循环引用问题

### 可达性分析

从GC roots开始往下搜索来获得引用链，当一个对象没有任何链相接，证明不可用。

#### GC Roots

- 虚拟机栈中的对象(本地变量表)
- 方法区中的静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中引用的对象（Native）

### 对象回收过程

要宣判死亡，要遍历两次，第一次不可达的对象标记第一次，看是否需要执行 finalize  方法

- 需要执行的话，会被放入一个队列中进行二次标记，除非真的没联系，否则就会被回收
- 不需要就回收

### 废弃常量

字符串常量没有String对象引用的话，那么这个字符串常量就是废弃常量

发生gc，有必要的话会回收

### 无用的类判断

- 没有实例
- 加载该类的ClassLoader已经被回收
- Class没有被引用，无法通过反射来访问

### 安全点

- 调用方法之后
- 循环的末尾
- 方法返回前
- 抛异常的位置

## 垃圾收集算法

### 标记清除算法

首先进行标记，在标记完成之后，统一进行回收

- 效率低
- 会产生大量不连续碎片

![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/63707281.jpg)

### 复制算法

每次使用一半，清除对象之后，复制到另一块内存，然后一次性清理掉空间

![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/90984624.jpg)

### 标记-整理算法

每次标记之后，存活的对象都往一端移动，然后清理掉边界以外的内容

![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/94057049.jpg)

### 分代收集

新生代    复制

老年代 	标记清除 标记整理

## 垃圾收集器

- serial之类的 因为采用的是复制算法   所以分配内存采用的是指针碰撞
  - Serial 收集器使用复制算法进行回收复制算法的思想是将eden和from区活跃的对象复制到to区，并清空eden区和from区，如果to区满了，那么部分对象将会被晋升移动到老年代，随后交换from和to区。 
- cms因为内存块并不整齐   所以分配的时候使用的是空闲链表

### Serial

单线程收集器 在进行收集垃圾的时候需要stop the world

 **新生代采用复制算法，老年代采用标记-整理算法。** 

### ParNew收集器

Serial的多线程版本，除了垃圾回收多线程之外，其他一样，也就是说还是需要stop the world，只不过垃圾回收过程加快

 **新生代采用复制算法，老年代采用标记-整理算法。**

**并行和并发概念补充：**

- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

### Parallel Scavenge

跟ParNew基本一样，只不过关注的是吞吐量( **CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值** )，关注用户体验。

### Serial Old

Serial 多线程版本

### cms

 **CMS（Concurrent Mark Sweep）** 

是一种以获取最短回收停顿时间为目标的收集器，是第一款真正意义上的并发收集器，使得垃圾回收线程和用户线程同时工作

CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

初始标记和重新标记都是要停止用户线程来进行标记的

![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/82825079.jpg)

- cpu资源敏感
- 导致大量空间碎片

G1

- 初始标记
- 并发标记
- 最终标记
- 筛选回收