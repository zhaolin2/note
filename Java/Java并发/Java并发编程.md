# 并发编程

并发(concurrent)，在操作系统中，是指在同一个时间段内有几个程序都处于运行期间，并且这几个程序都在同一个处理机上运行。

并行(parallel)是指，当系统有一个以上的CPU的时候，一个CPU执行一个程序，另一个CPU执行另外一个进程，互相不抢占CPU资源。

![1601553547230](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1601553547230.png)

## 三要素

- 原子性  一个或者多个操作  要么全部成功 要么全部失败
- 可见性 一个线程对共享变量的修改 另一个线程能立刻看到
- 有序性  执行顺序按照代码先后顺序执行

JMM解决了可见性和有序性的问题，而锁或者valiatile+cas被用来保证原子性

# 常见问题及解决方案

- 集合的话，可以考虑juc的集合类
- 要保证数值或者对象的安全，考虑atomic的类
- 线程重复利用，考虑线程池
- 线程控制，考虑CountDownLatch/Semaphore
- 锁相关，synchronized和lock包下边的AQS相关

##  java线程状态

- 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。

- 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
  线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
- 阻塞(BLOCKED)：表示线程阻塞于锁。
- 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
- 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
- 终止(TERMINATED)：表示该线程已经执行完毕。

# 并发问题和内存模型

Java在多线程的问题上所采用的是共享内存的实现方式，所以为了保证共享内存的正确性(可见性，有序性，原子性)，引入了一组规则定义了多线程读写操作的规范，这个就被称为 Java Memory Model(JMM)。

Java一般使用下边的来保证多线程安全

- Synchronized
- AQS
  - ReentrantLock
- volatile
- Atomic

# 线程通信

- synchronized
- wait notify
- semaphore
- 管道
- join
- sleep
- ThreadLocal   
  -  InheritableThreadLocal 可以父子线程共享副本值

# 线程和共享数据

在JVM中，每个线程独享栈内存，其中包括局部变量，栈帧，但是栈中的数据仅仅限于基本类型和对象引用，栈是无法保存对象的，只能保存对象的引用

堆内存是所有线程共享的，堆中只包含对象，无法保存基本类型和对象引用，其中注意的是，数组是保存在堆上的，即使是基本类型的数组也保存在堆中。

# CPU时间片

 分时操作系统是把CPU的时间划分成长短基本相同的时间区间,即”时间片”，通过操作系统的管理，把这些时间片依次轮流地分配给各个“用户”使用。 

 如果某个“用户”在时间片结束之前，整个任务还没有完成，“用户”就必须进入到就绪状态，放弃CPU，等待下一轮循环。此时CPU又分配给另一个“用户”去使用。 