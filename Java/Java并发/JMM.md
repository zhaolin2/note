# 内存模型

- 线程之间如何通信
- 线程之间如何同步

![两种并发模型的比较](D:\note\images\两种并发模型的比较.png)

## 在java中采用的是**共享内存**的并发模型

## JMM

- Java线程之间的通信由Java内存模型（简称JMM）控制，

- 从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。 

 JMM定义了线程和主内存之间的抽象关系：

- 线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），

- 本地内存中存储了该线程以读/写共享变量的副本。 
- 线程的所有操作只能在本地内存完成

![JMM抽象示意图](D:\note\images\JMM抽象示意图.jpg)

## 内存交互协议

![](https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190513144649.png)

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
- unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

这八个步骤要符合下边规则：

1. 不允许read和load，store和write操作之一单独出现。
2. 不允许一个线程丢弃它最近的assign操作。即变量在工作内存中改变了  就必须把变化同步回主内存
3. 一个新的变量只允许在主内存中诞生，不允许工作内存直接使用未初始化的变量。
4. 一个变量同一时刻只允许一条线程进行lock操作，但同一线程可以lock多次，lock多次之后必须执行同样次数的unlock操作
5. 如果对一个变量进行lock操作，那么将会清空工作内存中此变量的值。
6. 不允许对未lock的变量进行unlock操作，也不允许unlock一个被其它线程lock的变量
7. 如果一个变量执行unlock操作，必须先把此变量同步回主内存中

 ## 重排序

- 编译器优化重排序
- 指令级并行重排序
- 内存系统重排序

## happens before
- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
- 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
- volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
- 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
- start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
- join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
- 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。
## 内存屏障

通过插入内存屏障（Memory Barrier）可以阻止特定类型的指令重排。JMM将内存屏障划分为四种：

| 屏障类型            | 示例                     | 描述                                                         |
| :------------------ | :----------------------- | :----------------------------------------------------------- |
| LoadLoad Barriers   | Load1-LoadLoad-Load2     | Load1数据装载过程要先于Load2及所有后续的数据装载过程         |
| StoreStore Barriers | Store1-StoreStore-Store2 | Store1刷新数据到内存的过程要先于Strore2及后续所有刷新数据到内存的过程 |
| LoadStore Barriers  | Load1-LoadStore-Store2   | Load1数据装载要先于Strore2及后续所有刷新数据到内存的过程     |
| StoreLoad Barriers  | Store1-StoreLoad-Load2   | Store1刷新数据到内存的过程要先于Load2及所有后续的数据装载过程 |

## MESI

CPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示):
- M: 被修改（Modified) 该缓存行**只被缓存在该CPU的缓存**中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。
- E: 独享的（Exclusive) 该缓存行**只被缓存在该CPU的缓存中**，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。
- S: 共享的（Shared) 该状态意味着该缓存行可能被**多个CPU缓存**，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。
- I: 无效的（Invalid） 该缓存是无效的
读要求：一个缓存除在Invalid状态外都可以满足cpu的读请求，一个invalid的缓存行必须从主存中读取（变成S或者 E状态）来满足该CPU的读请求。
写要求：一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于S状态，必须先将其它缓存中该缓存行变成Invalid状态
## cpu缓存
按照读取顺序与CPU结合的紧密程度，CPU缓存可分为：

- 一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存

- 二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半

- 三级缓存：简称L3 Cache，部分高端CPU才有