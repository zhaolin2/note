23种设计模式

# 总述

创建型模式，共五种：

- 工厂方法模式   定义一个创建对象的接口，让子类决定实例化哪个类
- 抽象工厂模式
  - 提供一个创建一系列相关或相互依赖对象的接口(可以创建不同类型的工厂)
- 单例模式  保证一个类只有一个实例，并且提供一个全局的访问点
- 建造者模式   把一个复杂对象的表示和创建分离，简单化复杂对象的创建
- 原型模式

结构型模式，共七种：

- 适配器模式  
  - 把一个类的接口转换为客户希望的另一个接口  使得原来不兼容的类可以一起工作
- 装饰器模式  动态的为对象添加一些额外的职责
- 代理模式
- 外观模式
- 桥接模式
- 组合模式
- 享元模式

行为型模式，共十一种

- 策略模式
- 模板方法模式   定义一个操作的中算法的框架，把一些步骤延迟到子类中
- 观察者模式  当一个对象的状态发生改变的时候，所有依赖的都会得到通知
- 迭代子模式
- 责任链模式     解耦请求的发送者和接收者，使得多个对象都有机会处理这个请求
- 命令模式
- 备忘录模式
- 状态模式
- 访问者模式
- 中介者模式
- 解释器模式

![](https://www.hollischuang.com/wp-content/uploads/2016/03/57a92d42-4d84-3aa9-a8b9-63a0b02c2c36.jpg)

# 单例模式

单例模式是为了减少内存的开销，比如频繁的创建和销毁实例

实现方式大概有下边这几种：

-  饿汉式  类加载的时候就初始化
   - static对象
   - 静态代码块
   - 静态内部类
-  懒汉式  使用的时候才会去加载
   - 线程安全的需要使用DCL来进行初始化
     - DCL可以使用volatile或者final来实现
-  使用枚举来实现

为了防止序列化机制破坏单例，应该重写Serializable接口的readResolve方法

## 单例举例以及使用场景

- JDK中RunTime的实现

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    public static Runtime getRuntime() {
        return currentRuntime;
    }

    private Runtime() {}
}
```

使用场景：

当一个类的对象只需要或者只可能有一个时，应该考虑单例模式。

如果一个类的实例应该在JVM初始化时被创建出来，应该考虑使用饿汉式单例。

如果一个类的实例不需要预先被创建，也许这个类的实例并不一定能用得上，也许这个类的实例创建过程比较耗费时间，也许就是真的没必须提前创建。那么应该考虑懒汉式单例。

在使用懒汉式单例的时候，应该考虑到线程的安全性问题。

# 工厂方法

在工厂方法中，一般包括两种对象，最高层次的抽象工厂和最高层次的抽象产品，来通过具体的工厂来创建具体的产品。

在需要添加实现的的时候只需要添加实例工厂即可。

## 工厂方法具体实现

什么时候要使用工厂方法？

- 创建对象需要大量重复的代码。

- 创建对象需要访问某些信息，而这些信息不应该包含在复合类中。

- 创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。

### Collection中的iterator方法

 `java.util.Collection`接口中定义了一个抽象的`iterator()`方法，该方法就是一个工厂方法。 

对于`iterator()`方法来说`Collection`就是一个根抽象工厂，下面还有`List`等接口作为抽象工厂，再往下有`ArrayList`等具体工厂。

`java.util.Iterator`接口是根抽象产品，下面有`ListIterator`等抽象产品，还有`ArrayListIterator`等作为具体产品。

### JDBC数据库开发

# 抽象工厂



# 建造者模式

将对象的构建和表示相分离，使得同样的构建过程可以创建不同的表示

分离对象属性和创建过程

# 代理模式







比如有20个属性 重要的有3 4个，并且有一些属性还有一定的限制，比如在属性a=1的情况下，属性b只能为2，3，4.

建造者模式实现

-  Guava的Cache、ImmutableMap 
-  mybatis sqlsessionFactory
-  Environment 

 Builder里面直接new对象的方式，MyBatis的SqlSessionFactoryBuilder就是这种写法，适用于属性之间关联不多且大量属性都有默认值的场景。 

 Guava的Cache都是这种写法，适用于属性之间有一定关联性的场景，例如车的长宽高与轴距都属于车型一类、排量与马力都与性能相关，可以把某几个属性归类，然后让开发者指定大类即可。 