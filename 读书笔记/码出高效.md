## 1.1 基础和位运算 

一条电路线被称为一位，为1个byte，简写为b。

8个bit组成一个单位，即1个Byte，简写为B。

1024个Byte简写为KB。

```shell
# 右移  整数补0 负数补1
>> 

# 无符号右移 高位补0 不区分正负数
>>> 

# &&具有短路功能
&&

# ||具有短路功能
||
```

## 1.2 浮点数

单精度浮点数 一般分配4个Byte来进行存储

- 符号位 1位
- 有效数字 23位
- 指数 8位

在金融业，推荐使用整型来存储最小单位的值，展示的时候进行转换

- 使用数组来保存小数部分的数值

在数据库进行保存的时候，推荐使用decimal

## 1.3 字符集和乱码

特殊的换行符 10 13

- LF \n
- CR \r

不同操作系统所使用的换行不一样

UNIX 新版MAC

- \n

Windows

- \r\n

旧版Mac

- \r

Unicode 的编码格式有三种， UTF-8 、UTF-16 、UTF-32, 

UTF ( Unicode Transformation Format ）即Unicode 字符集转换格式，可以理解为对Unicode 的压缩方式

## 信息安全

### sql注入

```sql
update table set memo= # -- !#(@ "where use_id=12345 ;
```

解决方案：

- 过滤用户输入参数中的特殊字符，从而降低被SQL注入 的风险。
- 禁止通过字符串拼接的SQL 语句，严格使用参数绑定传人的SQL 参数
- 合理使用数据库访问框架提供的防注入机制

正确使用参数化绑定SQL 变量，这样才能有效地避免SQL 注入。

# 面向对象

- 封装
- 继承
- 多态   更像是继承行为衍化出来的进化能力
- 抽象

抽象类和接口纠结的话 推荐使用接口

抽象类更像是一个is a的关系  模板设计

接口被实现的时候体现的是can do的关系  契约设计



内部类本身就是外部类的一个属性

- 静态内部类 static class StaticInnerClass{}
- 成员内部类 private class InstanceInnerClass{}
- 局部内部类
- 匿名内部类 (new Thread(){}).start;

ArrayList的subList类

-  修改subList，导致原list也受到影响 
-  修改原list，导致sublist的所有操作都会报错 

访问权限控制符任何地方包外子类包内类内
public OK OK OK OK
protected :\() OK OK OK
无\{) \() OK OK
private 1\0 NO NO OK

public ：可以修饰外部类、属性、方法，表示公开的、无限制的，是访问限
制最松的一级，被其修饰的类、属性和方法不仅可以被包内访问，还可以跨类、
跨包访问，甚至允许跨工程访问。
• protected : 只能修饰属性和方法，表示受保护的、有限制的，被其修饰的属
性和方法能被包内及包外子类访问。注意，即使并非继承关系， protected 属
性和方法在同一包内也是可见的。
·无·即无任何访问权限控制符，如示例中的noneMethod 方法，没有任何
修饰符。千万不要说成default ， 它并非访问权限控制符的关键字，另外，在
JDK8 接口中引入default 默认方法实现， 更加容易混淆两者释义。无访问权
限控制符仅对包内可见。虽然无访问权限控制符还可以修饰外部类，但是定
义外部类极少使用无控制符的方式，要么定义为内部类，功能内聚，要么定
义公开类，即public class ，包外也可以实例化。
59 1
仅供非商业用途或交流学习佼用
码出高效， Java 开发手册
• privat巳只能｛嗲饰属性、方法、内部类。表示
格的级’被其修饰的属性或方法只能在该类内部访问’子类、包内均不能
访问， 更不允许跨包访问。

类之间的关系

继承］ extends (is-a） 。
·［ 实现］ implements (can - do） 。
·［ 组合］ 类是成员变量（contai ns-a） 。

- 强关系  强调部分和整体的关系，所有成员一起完成一件事 生命周期相同

·｛ 聚合｝ 类是成员变量（has-a） 。

- 可以拆分的整体和部分的关系  部分可以拆分给另外的整体

·［ 依赖］ import 类（use-a） 。

方法签名包括方法名称和参数列表，是JVM标记方法的唯一索引

形参：方法定义阶段

实参：方法调用阶段

不要使用Object作为可变参数，因为过于灵活，类型不好判断

参数预处理：

- 入参保护
  - 需要对入参的数据量进行判断，超出则返回错误给客户端
- 参数校验

需要进行参数校验的场景，
·调用频度低的方法。
·执行时间开销很大的方法。此情形中， 参数校验时间几乎可以忽略不计， 但
如果因为参数错误导致中间执行回退或者错误，贝lj 得不偿失。
·需要极高稳定性和可用性的方法。
· 对外提供的开放接口。
· 敏感权限入口。
不需要进行参数校验的场景
· 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。
·底层调用频度较高的方法。参数错误不太可能到底层才会暴露问题。一般
仅供非商业用途或交流学习使用
第2 章面向对象
DAO 层与Serv ice 层都在同个应用中，部署在同一台服务器中，所以可以
省略DAO 的参数校验。
·声明成private 只会被自己代码调用的方法。如果能够确定调用方法的代码传
入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。

建议在类定义中， 类内方法定义顺序依次是公有方法或保护方法＞私有方法＞ getter/setter 方法。

pojo

Plain Ordinary Java Object ， 简单的
Java 对象）类

在本书中， POJO 专指只包含getter、setter 、toString 方法的简单类，
常见的POJO 类包括DO(Domain Object） 、BO(Business Object） 、DTO(Data Transfer
Object） 、VO(View Object）、AO(Application O均ect） 。POJO 作为数据载体，通常用于
数据传输，不应该包含任何业务逻辑。因此，在POJO 类中， getter 与setter 不但是重
要的组成部分， 更是与外界进行信息交换的桥梁。

getter和setter可能会出错的地方

- get和set中添加业务逻辑
- 同时定义isXxx和getXxx
  - 序列化的时候会引起冲突
- 相同的属性名可能带来歧义
  - 避免在父子类和不同代码块的局部变量之间采用完全相同的命名

动态绑定

元空间有一个方法表保存着每个可以实例化
类的方法信息， 只矶4 可以通过方法表快速地激活实例方法。

方法的覆写可以总结成容易记忆的口诀“ 一大两小两同”。

一大子类的方法访问权限控制符只能相同或变大。
· 两小，抛出异常和返回值只能变小， 能够转型成父类对象。子类的返回值、
抛出异常类型必须与父类的返回值、抛出异常类型存在继承关系。
· 两同i 方法名和参数必须完全相同。

方法名称＋参数类型＋参数个数，组成一个唯一键，称为方法签名，JVM通过这个
唯一键决定调用哪种重载的方法。

JVM在重载方法中，选择合适的目标方法的顺
序如下

- 
  精确匹配
-  如果是基本类型，自动转化为更大表示范围的基本类型
- 通过自动拆装箱
- 通过子类向上转型继承路线依次匹配
- 通过可变参数进行匹配

引用变量 Reference Variable refvar

引用指向的实际对象 Referred Object  refobj

单个方法不超过80行

if else for while do-while 等语句必须使用大括号

条件表达式中不允许有赋值操作，也不允许在判断表达式中出现复杂的逻辑组合

多层嵌套不超过三层

避免使用取反运算符

注释

- Nothing is strange   
  - 业务代码需要一直修改  所以一定需要写注释
- less is more
- Advance with the times
  - 代码修改  注释也要修改

注释：

注释内容不仅局限于解释属性值的定义，还可以包括注意事项，业务逻辑

枚举注释：

- 枚举类代码及其稳定
- 枚举类的删除和修改都存在很大的风险 
  - 不能直接删除  需要标注为过时 并且注明过时的逻辑考虑和业务背景

# JVM

字节码  ByteCode

热点代码 JIT动态编译为机器码

字节码主要命令：

加载或者存储指令

( I ）将局部变量加载操作栈中。如ILOAD （将int 类型的局部变量压入栈）
和ALOAD （将对象引用的局部变量压入栈）等。
( 2 ）从操作栈顶存储到局部变量表。如ISTORE，ASTORE

( 3 ）将常量加载到操作栈顶，这是极为高频使用的指令。如ICONST,
BIPUSH 、SIPUSH 、LDC 等。
•ICONST 加载的是-1 ～ 5 的数（ICONST 与BIPUSH 的加载界限）。
• BIPUSH ，即Byte Immediate PUSH ，加载128 ～ 127 之间的数。
• SIPUSH ，即Short Immediate PUSH ，加载32768 ～ 32767 之间的数。
•LDC ，即Load Constant ，在一2147483648 ～ 2147483647 或者是字符串时，
JVM采用LDC 指令压入栈中。

2.运算指令

对两个在操作栈帧的值进行运算，并把接口写入栈顶 IADD，IMUL

3.类型转换

显式的转换两种不同的数值类型。I2L,D2F

4.对象创建和访问指令

( I ｝创建对象指令。如NEW 、NEWARRAY 等。
( 2 ｝访问属性指令如GETFIELD 、PUTFIELD 、GETSTATIC 等。
( 3 ｝检查实例类型指令。如INSTANCEOF, CHECKCAST 等。

5. 操作栈管理指令
JVM 提供了直接控制操作栈的指令，常见指令如下·
( I ）出栈操作。如POP 即一个元素， POP2 即两个元素。
( 2 ｝复制栈顶元素并压入栈， 如DUP 。

6.方法调用和返回指令

常见指令如下
( I ) INVOKEYIRTUAL 指令 调用对象的实例方法。
( 2) INVOKESPECIAL 指令  调用实例初始化方法、私有方法、父类方法等。
( 3 ) INVOKESTATIC  调用类静态方法。
( 4 ) RETURN 指令 返回VOID 类型。

7.同步指令

ACC_SYNCHRONIZED 标志同步方法

MONITORENTER 和MONITOREXIT 支持synchronize d 语义。

## 类加载过程

ClassLoader+包名+类名为Key来查找.class

分配内存  cas 区域加锁

日志

- 代码规约推荐日志文件至少要保存15天
  - 根据重要程度 文件大小  磁盘空间来延长保存时间

- debug 记录对调试程序有帮助的信息
- info 记录正常运行的现场
- warn 记录现场，表明可能出现潜在错误的可能
- error  发生了错误 需要被关注
- fatal 出现了严重的错误

## 集合

尽量试用泛型来定义集合

Integer数组可以赋值为object数组

List不行

，＜？ extends T＞是Get First ， 适用于， 消费集合元素为主
的场景；＜？ super T> 是Put First ，适用于，生产集合元素为主的场景。

初始化大容量的CopyOnArrayList的时候，可以先添加进ArrayList中，然后